/* =========================================================
.(l
 TEXT id;               /* id for the instance of the organization */
 TEXT type   ;          /* structure type used in this tree */
.)l
Description:
 Encapsulated form of the double tree for C++.
This is exactly like the single tree, except that nodes at the same
level form a double-linked ring.
For more description, see ZZ_ORG_DOUBLE_RING
.sp
Note that the iterator has both ++ and -- operators.
.sp
 For local scope use ZZ_LOCAL_DOUBLE_TREE(). See description
of ZZ_LOCAL_SINGLE_RING() on how to work in local scope.
.(l
Example of the use:
   class myStr {
       ZZ_EXT_myStr
       int a,b,c,d;
   };
   ZZ_HYPER_DOUBLE_TREE(myTree,myStr)

   myStr *p,*c;

    ...
   myTree_iterator ti(p); // visit all children of p
   while(c=ti++){
     ...  // c is the next child
   }
.)l
  ========================================================== */ 
#define ZZ_HYPER_DOUBLE_TREE(id,type) \
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */ \
ZZ_BASIC_DOUBLE_TREE(id,type,ZZ_EXTERN,id)

#define ZZ_LOCAL_DOUBLE_TREE(id,type,where) \
ZZ_BASIC_DOUBLE_TREE(id,type,static,where :: id)

#define ZZ_BASIC_DOUBLE_TREE(id,type,scope,where) \
class ZZFP(ZZH,id) { \
public: \
  type *par(type *c){type *p;\
                  ZZ_PARENT_DOUBLE_TREE(id,c,p); return(p);}\
  type *child(type *p){type *c;\
                   ZZ_CHILD_DOUBLE_TREE(id,p,c); return(c);}\
  type *chld(type *p){ return p->ZZFP(ZZc,id);}\
  type * fwd(type *t){type *s;\
                 ZZ_FORWARD_DOUBLE_TREE(id,t,s); return(s);}\
  type * bwd(type *t){type *s;\
                 ZZ_BACKWARD_DOUBLE_TREE(id,t,s); return(s);}\
  void set(type *c){ZZ_SET_DOUBLE_TREE(id,NULL,c);}\
  void add(type *p,type *c);\
  void ins(type *t,type *s);\
  void app(type *t,type *s);\
  void del(type *t);\
};\
scope ZZFP(ZZH,id) id; \
class ZZFN(id,iterator){ \
   type *beg;\
   type *nxt;\
public:\
   ZZFN(id,iterator)(type *p){start(p);}\
   ZZFN(id,iterator)(){beg=nxt=NULL;}\
   void start(type *p){if(p)beg=where.chld(p); else beg=NULL; nxt=NULL;} \
   type* operator++(){type *p;\
      if(nxt)p=nxt; else if(beg)p=where.fwd(beg); else p=NULL;\
      if(p==beg)nxt=beg=NULL; else nxt=where.fwd(p); return(p);}\
   type* operator--(){type *p;\
      if(nxt)p=nxt; else if(beg){p=beg; beg=where.fwd(beg);} else p=NULL;\
      if(p==beg)nxt=beg=NULL; else nxt=where.bwd(p); return(p);}\
}

/* _______________________________________________________________________ */
void ZZV$ ZZH$ :: add(ZZ1$ *p,ZZ1$ *c){ZZ_ADD_DOUBLE_TREE($,p,c);}
void ZZV$ ZZH$ :: ins(ZZ1$ *t,ZZ1$ *c){ZZ_INSERT_DOUBLE_TREE($,t,c);}
void ZZV$ ZZH$ :: app(ZZ1$ *t,ZZ1$ *c){ZZ_APPEND_DOUBLE_TREE($,t,c);}
void ZZV$ ZZH$ :: del(ZZ1$ *t){ZZ_DELETE_DOUBLE_TREE($,NULL,t);}
