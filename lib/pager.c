/* pager is a self-enclosed program, which is a part of the library,
 * but is itself coded with OrgC. File pager.h is automatically generated.
 * It corresponds to the default file zzincl.h.
 * File pager.k is the equivalent of zzincl.h,
 * file pager.g is the equivalent of "zzfunc.c".
 * These files are generated by running zzprep on pager.h.
 *
 * The reason why we can add pager in this form is that internal objects
 * used in the pager do not have to be persistent. When the pager is closed,
 * all its content is already stored on its file, and if the pager is
 * invoked again on the same file by another program, the same data
 * is automatically available.
 *
 * Also, a neutral interface separates the user code from the pager.
 * The interface passes only record index, record size, and a buffer.
 * No pointers to user object are being passed. Pager operates like an
 * independent program in terms of global variables, orgC typetables, etc.
 * The only reason why it links to the rest of the library (msgs.c)
 * is the centrally controlled allocation and error messages.
 *
 * Pager is essentially a C functions which, in case of C++, is wrapped
 * under a special hyper class. It is not included in UTILITIES,
 * because it is a rather specialized operation, and it would increase
 * the size of executables for enybody who needs saving to disk.
 *
 * Pager is implemented in a way which permits to keep several
 * pagers operating independently at the same time. The pointer to the
 * required Head (each Head represents one pager) is being passed 
 * as a "general-link", cast as (char *). In this way, different user
 * objects can have their own pagers, while the system is prevented
 * from saving pagers to disk.
 *
 * A rather tricky sequence is required to make the pager a part
 * of the OrgC library. First, the library must be compiled without
 * the pager. Then the preprocessor is compiled, which depends
 * on the general part of the library. Then the pager is compiled,
 * (it needs the preprocessor), and can be added to the library.
 * Jiri Soukup, Oct.11/91
 */
#include "pager.h"
#include "pager.g"
#ifdef HP
#include <sys/stat.h>
#endif
#ifdef IBM
#include <sys/stat.h>
#endif
#ifdef SCO
#include <sys/stat.h>
#endif
#ifdef DEC
#include <sys/stat.h>
#endif
#ifdef SUN
#include <sys/stat.h>
#endif

/* offset for lseek() is always  in bytes from the beginning of the file */
#ifdef ZZ_ANSI
static void pageToMemory(Head *, Page *);
static void pageToDisk(Head *, Page *);
static int cmpPager(const void *,const void *);
static Page *loadPage(Head *, int );
void *ZZnewObj(int,int);
int ZZdelObj(char *);
#else
static void pageToMemory();
static void pageToDisk();
static int cmpPager();
static Page *loadPage();
void *ZZnewObj();
int ZZdelObj();
#endif

/* ------------------------------------------------------------- */
/* ZZformPager() opens a new pager, and returns pointer to its header
 * casted as (char *). This is one of very few exceptions where
 * casting is used, and the true purpose is to block the expansion
 * mechanism from saving internal pager objects to disk.
 * When the function is called on a file which is already used,
 * the error is reported, and no action is taken.
 * If the file already exists, the old file is automatically used.
 * If the file does not exist yet, a new file is being opened.
 * Any problems with opening the files are reported through the general
 * message functions.
 */
#ifdef ZZ_ANSI
char *ZZformPager(char *fName,int pageSize,int numPages,int init)
{
    char c,*p,*fn;

#else
char *ZZformPager(fName,pageSize,numPages,init)
char *fName;
int pageSize;
int numPages;
int init; /* 0=no initialization, 1=initial as 0, 2=initial as ' ' */
{
    char c,*p,*fn;
#endif
    Head *hp;
    int i;

    if(numPages<=0)numPages=1;
    ZZ_A_TRAVERSE(zz_heads,hStart,hp){
        ZZ_FORWARD(zz_fileName,hp,fn);
        if(!strcmp(fName,fn)){
            ZZmsgS(36,fName); /* parser file already in use */
            return((char *)hp);
        }
    }ZZ_A_END;
    ZZ_PLAIN_ALLOC(Head,1,hp);
    ZZ_ADD(zz_heads,hStart,hp);
    ZZ_STRING_ALLOC(fName,fn);
    ZZ_ADD(zz_fileName,hp,fn);
#ifdef ZORTECH
    hp->handle=open(fName,O_CREAT | O_RDWR,S_IREAD | S_IWRITE);
#else
#ifdef MAC
    hp->handle=open(fName,O_CREAT | O_RDWR);
#else

#ifdef HP
#ifndef ZZcplus
    hp->handle=open(fName,O_CREAT | O_RDWR); /* internal HP */
#endif
#else

#ifdef DOS
    hp->handle=open(fName,O_CREAT | O_RDWR | O_BINARY,S_IREAD | S_IWRITE);
#else
    hp->handle=open(fName,O_CREAT | O_RDWR,S_IREAD | S_IWRITE);
#endif
#endif
#endif
#endif

    if(hp->handle<0){
        ZZmsgS(0,fName); /* problem to open the file */
        return((char *)NULL);
    }
    hp->pageSize=pageSize;
    hp->numPages=numPages;
    hp->buffSize=pageSize*numPages;
    hp->buffFill=0;
    hp->fileFill=lseek(hp->handle, 0L, 2); /* 2=end of file position */
    hp->mb=(char *)ZZnewObj(hp->buffSize,0);
    if(hp->mb==NULL){
        ZZmsgS(37,fName);
        ZZ_DELETE(zz_fileName,hp,fn);
        ZZ_STRING_FREE(fn);
        ZZ_DELETE(zz_heads,hStart,hp);
        ZZ_PLAIN_FREE(Head,1,hp);
        return((char *)NULL);
    }
    hp->ini=NULL;
    if(init>0){
        hp->ini=(char *)ZZnewObj(pageSize,0);
        if(hp->ini==NULL)ZZmsgS(39,fName);
        else {
            if(init==1)c='\0'; else c=' ';
            for(p=hp->ini, i=0; i<pageSize; i++,p++)*p=c;
        }
    }

    /* form empty hash table with plenty of space */
    ZZ_FORM_HASH(zz_pageHash,hp,2*numPages);
    return((char *)hp);
}
/* ------------------------------------------------------------- */
/* ZZioPager writes/reads a stream of bytes into the paging area.
 * The stream may overlap page boundaries.
 * When buff is given, it loads the result into it. When not
 * (buff=NULL), it only returns the address. In either case,
 * the call loads all the pages required for the n characters
 * into the memory buffer.
 */
#ifdef ZZ_ANSI
char *ZZioPager(int io,char *head,LONG ind,char *buff,int n)
{

#else
char *ZZioPager(io,head,ind,buff,n)
int io; /* 0=to read from the pager, 1=to write into pager */
char *head; /* disguised head for this pager */
LONG ind; /* index, position in the paging area */
char *buff; /* object to be read/written, NULL=just address */
int n;    /* number of characters to move */
/* returns address into the memory buffer */
{
#endif
    LONG start; /* start of the page */
    LONG i1,i2; /* limits of the area to fill */
    LONG moved;  /* number of bytes moved within one page */
    Head *hp;
    int pSize,pNo,i,k;
    static Page tp;
    Page *pp;
    char *c,*first;

    if(!head)return((char *)NULL);
    first=NULL;
    hp=(Head *)head;
    pSize=hp->pageSize;
    pNo=(int)(ind/pSize); /* page number */
    start=pNo*pSize; /* start of the first page */
    for(i1=ind, i2=ind+n, k=0; i1<i2; i1=i1+moved, start=start+pSize, pNo++){
        moved=pSize-(i1-start);
        tp.pageNo=pNo;
        ZZ_GET_HASH(zz_pageHash,hp,&tp,pp);
        if(!pp)pp=loadPage(hp,pNo);
        if(!pp){
            ZZ_FORWARD(zz_fileName,hp,c);
            ZZmsgS(38,c);
            return((char *)NULL);
        }
        if(!first)first=pp->where;
        if(buff){ /* copy only if buff is given */
            for(c=pp->where, i=(int)(i1-start); i<pSize; i++,k++){
                if(k>=n)break; /* copy finished */
                if(io==1)c[i]=buff[k];
                else     buff[k]=c[i];
            }
        }
        else k+=((int)moved);
        /* move the page to the top of the stack */
        ZZ_DELETE(zz_pages,hp,pp);
        ZZ_ADD(zz_pages,hp,pp);
        ZZ_SET(zz_pages,hp,pp);
        /* avoid loading a page if not needed */
        if(k>=n)return(first+(int)(ind-start));
    }
    return(first+(int)(ind-start));
}
/* ------------------------------------------------------------- */
/* Functions to control the hashing */

#ifdef ZZ_ANSI
int zz_hashCmp_zz_pageHash(char *s1,char *s2)
#else
int zz_hashCmp_zz_pageHash(s1,s2)
char *s1, *s2;
#endif
{ Page *p1,*p2; p1=(Page *)s1; p2=(Page *)s2;
  if(p1->pageNo==p2->pageNo)return(0); else return(1); }

#ifdef ZZ_ANSI
int zz_hashInd_zz_pageHash(char *s,int size)
{ Page *p; int ZZhashInt(int key,int size); p=(Page *)s;
#else
int zz_hashInd_zz_pageHash(s,size)
char *s;
int size;
{ Page *p; int i,ZZhashInt(); p=(Page *)s;
#endif
  return(ZZhashInt(p->pageNo,size)); }
/* ------------------------------------------------------------- */
/* loadPage() loads the page of the given number into the memory buffer.
 * Decisions to be made:
 * Memory buffer assignment:
 *     - not full number of pages used: assign next section;
 *       create a new page object;
 *     - full number of pages is used: find the last page,
 *       send it to disk, copy new page into the same area,
 *       remove the Page from the stack and from the hash table;
 *       reassign pageNo; move the Page to a new position in
 *       the stack and in the hash table.
 */ 
#ifdef ZZ_ANSI
static Page *loadPage(Head *hp, int n)

#else
static Page *loadPage(hp,n)
Head *hp; /* head for this pager */
int n; /* page number to load */
#endif
{
    Page *pp;
    char *p,c;
    int i,pSize;

    pSize=hp->pageSize;
    if(hp->buffFill<hp->buffSize){
        /* page system not full, adding a new page */
        ZZ_PLAIN_ALLOC(Page,1,pp);
        pp->pageNo=n;
        pp->where=(&(hp->mb[hp->buffFill]));
        ZZ_ADD(zz_pages,hp,pp);
        ZZ_SET(zz_pages,hp,pp);
        ZZ_ADD(zz_pageHash,hp,pp);
        hp->buffFill+=pSize;

        if(hp->ini){ /* initialize the area */
            c=hp->ini[0];
            for(i=0, p=pp->where; i<pSize; i++, p++)*p=c;
        }
    }
    else {
        /* replace the oldest page */
        ZZ_CHILD(zz_pages,hp,pp);
        pageToDisk(hp,pp);
        ZZ_DELETE(zz_pages,hp,pp);
        ZZ_DELETE(zz_pageHash,hp,pp);
        pp->pageNo=n;
        ZZ_ADD(zz_pages,hp,pp);
        ZZ_SET(zz_pages,hp,pp);
        ZZ_ADD(zz_pageHash,hp,pp);
    }
    pageToMemory(hp,pp); /* if new data, this may result in no action */
    return(pp);
}
/* ------------------------------------------------------------- */
/* ZZclosePager() closes the given pager, sends all the information
 * to disk, closes the file, and frees all memory including the paging
 * buffer.
 *
 * The algorithm first sorts the list of all active pages, so that
 * when moving them to disk, no filler is required.
 */
#ifdef ZZ_ANSI
void ZZclosePager(char *hc)
{

#else
void ZZclosePager(hc)
char *hc;
{
#endif
    Page *pp;
    char *fn;
    Head *hp;

    hp=(Head *)hc;
    if(!hp || hp->handle<0)return;
    ZZ_SORT(zz_pages,cmpPager,hp); /* sort pages by pageNo */
    ZZ_A_TRAVERSE(zz_pages,hp,pp){
        pageToDisk(hp,pp);
    }ZZ_A_END;
    close(hp->handle);

    ZZdelObj(hp->mb);
    if(hp->ini)ZZdelObj(hp->ini);
    ZZ_DELETE(zz_fileName,hp,fn); /* disconnect the name */
    ZZ_STRING_FREE(fn); /* free the name */
    ZZ_FREE_HASH(zz_pageHash,hp); /* free the whole hash table */
    ZZ_A_TRAVERSE(zz_pages,hp,pp){ /* take pages from the stack */
        ZZ_DELETE(zz_pages,hp,pp);
        ZZ_PLAIN_FREE(Page,1,pp);
    }ZZ_A_END;
    ZZ_DELETE(zz_heads,hStart,hp); /* remove from list of pagers */
    ZZ_PLAIN_FREE(Head,1,hp);    /* destroy it */
}
/* ------------------------------------------------------------- */
/* Compare function for sorting pages in the increasing order of
 * page numbers. This will avoid using filler when closing a pager */
#ifdef ZZ_ANSI
static int cmpPager(const void *p1,const void *p2)

#else
static int cmpPager(p1,p2)
void *p1,*p2;
#endif
{
    Page *pp1,*pp2;
    pp1=(Page *)p1; pp2=(Page *)p2;
    if(pp1->pageNo<pp2->pageNo)return(-1);
    if(pp1->pageNo>pp2->pageNo)return(1);
    return(0);
}
/* ------------------------------------------------------------- */
/* Writing a page to the disk:
 *     - if the page is within the size of the file, just move it in;
 *     - if the page is outside of the current size, write a filler
 *       and then the new page; update fileFill info.
 */
#ifdef ZZ_ANSI
static void pageToDisk(Head *hp, Page *pp)
#else

static void pageToDisk(hp,pp)
Head *hp;
Page *pp;
#endif
{
    LONG newPos,size;
    int i;
    
    newPos=pp->pageNo;
    size=hp->pageSize;
    newPos=newPos*size;
    if(hp->fileFill<newPos){
        lseek(hp->handle, 0L, 2); /* 2=mode set to the end of file */
        /* creating a new section on disk */
        for(;hp->fileFill<newPos; hp->fileFill=hp->fileFill+size){
            /* filler pages must be initialized */
            i=ZZLONGToInt("pageToDisk",size);
            if(hp->ini) write(hp->handle, hp->ini,i);
            else         write(hp->handle, pp->where,i);
        }
    }
    /* over-writing old data on disk */
    lseek(hp->handle, newPos, 0); /* 0=offset mode from beg.of file */
    write(hp->handle, pp->where, hp->pageSize);
    if(hp->fileFill<newPos+size)hp->fileFill=newPos+size;
    return;
}
/* ------------------------------------------------------------- */
/* Moving a page from disk to memory - this is a straight byte transfer
 * If this section of the data is not on the disk yet, just do nothing.
 */
#ifdef ZZ_ANSI
static void pageToMemory(Head *hp, Page *pp)
#else

static void pageToMemory(hp,pp)
Head *hp;
Page *pp;
#endif
{
    LONG i,newPos,size;
    int pSize;
    char *p,s;
    
    pSize=hp->pageSize;
    newPos=pp->pageNo;
    size=pSize;
    newPos=newPos*size;
    if(hp->fileFill<=newPos){
        if(hp->ini){ /* avoid old garbage in the new page */
            s=hp->ini[0];
            for(p=pp->where, i=0; i<pSize; i++, p++)*p=s;
        }
        return;
    }
    lseek(hp->handle, newPos, 0); /* 0=offset mode from beg.of file */
    read(hp->handle, pp->where, hp->pageSize);
    return;
}
/* ------------------------------------------------------------- */
#ifdef ZZ_ANSI
static void blockWarnings(void){
#else
static void blockWarnings(){
#endif
ZZcustomPtr=ZZdiskIO;
ZZcustomPtr=ZZdebFLG; ZZdebFLG=ZZcustomPtr;
ZZnTbType=ZZpTbType; ZZpTbType=ZZnTbType;
ZZmemPool=ZZmemEnd; ZZmemEnd=ZZmemPool;
}
/* ------------------------------------------------------------- */
